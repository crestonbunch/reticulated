//! The Python grammar definition.
//!
//! The grammar is defined using a metagrammar syntax and autogenerated
//! using a procedural macro defined in the [`metagrammar`] module.
//!
//! The output of the macro is a function `next_state` which encodes the Python
//! grammar rules and can be used to build a Python parse tree based on input
//! Python tokens from a [`lexer::Lexer`].
//!
//! [`metagrammar`]: ../metagrammar/index.html
//! [`lexer::Lexer`]: ../lexer/struct.Lexer.html

extern crate metagrammar;
use metagrammar::build_grammar;

use lexer::tok;
use lexer::tokens::Token;

build_grammar! {
    SingleInput: "NEWLINE" | SimpleStmt | CompoundStmt "NEWLINE";
    FileInput: ("NEWLINE" | Stmt)* "ENDMARKER";
    EvalInput: TestList "NEWLINE"* "ENDMARKER";

    Decorator: "@" DottedName [ "(" [ArgList] ")" ] "NEWLINE";
    Decorators: Decorator+;
    Decorated: Decorators (ClassDef | FuncDef | AsyncFuncDef);

    AsyncFuncDef: "async" FuncDef;
    FuncDef: "def" "NAME" Parameters ["->" Test] ":" FuncBodySuite;

    Parameters: "(" [TypedArgsList] ")";
    TypedArgsList: (
        TfpDef ["=" Test] ("," TfpDef ["=" Test])* (
            ["," [
                "*" [TfpDef]
                ("," TfpDef ["=" Test])*
                (["," ["**" TfpDef [","]]])
                | "**" TfpDef [","]]
            ]
        )
        | "*" [TfpDef] ("," TfpDef ["=" Test])* (["," ["**" TfpDef [","]]])
        | "**" TfpDef [","]);
    TfpDef: "NAME" [":" Test];
    VarArgsList:
    VfpDef ["=" Test] ("," VfpDef ["=" Test])* [
        "," [
            "*" [VfpDef] ("," VfpDef ["=" Test])* ["," ["**" VfpDef [","]]]
            | "**" VfpDef [","]
        ]]
    | "*" [VfpDef] ("," VfpDef ["=" Test])* ["," ["**" VfpDef [","]]]
    | "**" VfpDef [","];
    VfpDef: "NAME";

    Stmt: SimpleStmt | CompoundStmt;
    SimpleStmt: SmallStmt (";" SmallStmt)* [";"] "NEWLINE";
    SmallStmt: (ExprStmt | DelStmt | PassStmt | FlowStmt |
                ImportStmt | GlobalStmt | NonLocalStmt | AssertStmt);
    ExprStmt: TestListStarExpr (AnnAssign | AugAssign (YieldExpr|TestList) |
                        [("=" (YieldExpr|TestListStarExpr))+] );
    AnnAssign: ":" Test ["=" (YieldExpr|TestList)];
    TestListStarExpr: (Test|StarExpr) ("," (Test|StarExpr))* [","];
    AugAssign: ("+=" | "-=" | "*=" | "@=" | "/=" | "%=" | "&=" | "|=" | "^=" |
                "<<=" | ">>=" | "**=" | "//=");
    // For normal and annotated assignments, additional restrictions enforced by the interpreter
    DelStmt: "del" ExprList;
    PassStmt: "pass";
    FlowStmt: BreakStmt | ContinueStmt | ReturnStmt | RaiseStmt | YieldStmt;
    BreakStmt: "break";
    ContinueStmt: "continue";
    ReturnStmt: "return" [TestListStarExpr];
    YieldStmt: YieldExpr;
    RaiseStmt: "raise" [Test ["from" Test]];
    ImportStmt: ImportName | ImportFrom;
    ImportName: "import" DottedAsNames;
    // note below: the ("." | "...") is necessary because "..." is tokenized as ELLIPSIS
    ImportFrom: ("from" (("." | "...")* DottedName | ("." | "...")+)
                "import" ("*" | "(" ImportAsNames ")" | ImportAsNames));
    ImportAsName: "NAME" ["as" "NAME"];
    DottedAsName: DottedName ["as" "NAME"];
    ImportAsNames: ImportAsName ("," ImportAsName)* [","];
    DottedAsNames: DottedAsName ("," DottedAsName)*;
    DottedName: "NAME" ("." "NAME")*;
    GlobalStmt: "global" "NAME" ("," "NAME")*;
    NonLocalStmt: "nonlocal" "NAME" ("," "NAME")*;
    AssertStmt: "assert" Test ["," Test];

    CompoundStmt: IfStmt | WhileStmt | ForStmt | TryStmt | WithStmt | FuncDef | ClassDef | Decorated | AsyncStmt;
    AsyncStmt: "async" (FuncDef | WithStmt | ForStmt);
    IfStmt: "if" NamedExprTest ":" Suite ("elif" NamedExprTest ":" Suite)* ["else" ":" Suite];
    WhileStmt: "while" NamedExprTest ":" Suite ["else" ":" Suite];
    ForStmt: "for" ExprList "in" TestList ":" Suite ["else" ":" Suite];
    TryStmt: ("try" ":" Suite
            ((ExceptClause ":" Suite)+
                ["else" ":" Suite]
                ["finally" ":" Suite] |
            "finally" ":" Suite));
    WithStmt: "with" WithItem ("," WithItem)*  ":" Suite;
    WithItem: Test ["as" Expr];
    // NB compile.c makes sure that the default except clause is last
    ExceptClause: "except" [Test ["as" "NAME"]];
    Suite: SimpleStmt | "NEWLINE" "INDENT" Stmt+ "DEDENT";

    NamedExprTest: Test [":=" Test];
    Test: OrTest ["if" OrTest "else" Test] | LambdaDef;
    TestNoCond: OrTest | LambdaDefNoCond;
    LambdaDef: "lambda" [VarArgsList] ":" Test;
    LambdaDefNoCond: "lambda" [VarArgsList] ":" TestNoCond;
    OrTest: AndTest ("or" AndTest)*;
    AndTest: NotTest ("and" NotTest)*;
    NotTest: "not" NotTest | Comparison;
    Comparison: Expr (CompOp Expr)*;
    // <> isn't actually a valid comparison operator in Python. It's here for the
    // sake of a __future__ import described in PEP 401 (which really works :-)
    CompOp: "<"|">"|"=="|">="|"<="|"<>"|"!="|"in"|"not" "in"|"is"|"is" "not";
    StarExpr: "*" Expr;
    Expr: XorExpr ("|" XorExpr)*;
    XorExpr: AndExpr ("^" AndExpr)*;
    AndExpr: ShiftExpr ("&" ShiftExpr)*;
    ShiftExpr: ArithExpr (("<<"|">>") ArithExpr)*;
    ArithExpr: Term (("+"|"-") Term)*;
    Term: Factor (("*"|"@"|"/"|"%"|"//") Factor)*;
    Factor: ("+"|"-"|"~") Factor | Power;
    Power: AtomExpr ["**" Factor];
    AtomExpr: ["await"] Atom Trailer*;
    Atom: ("(" [YieldExpr|TestListComp] ")" |
        "[" [TestListComp] "]" |
        "{" [DictOrSetMaker] "}" |
        "NAME" | "NUMBER" | "STRING"+ | "..." | "None" | "True" | "False");
    TestListComp: (NamedExprTest|StarExpr) ( CompFor | ("," (NamedExprTest|StarExpr))* [","] );
    Trailer: "(" [ArgList] ")" | "[" SubScriptList "]" | "." "NAME";
    SubScriptList: SubScript ("," SubScript)* [","];
    SubScript: Test | [Test] ":" [Test] [SliceOp];
    SliceOp: ":" [Test];
    ExprList: (Expr|StarExpr) ("," (Expr|StarExpr))* [","];
    TestList: Test ("," Test)* [","];
    DictOrSetMaker: ( ((Test ":" Test | "**" Expr)
                    (CompFor | ("," (Test ":" Test | "**" Expr))* [","])) |
                    ((Test | StarExpr)
                    (CompFor | ("," (Test | StarExpr))* [","])) );

    ClassDef: "class" "NAME" ["(" [ArgList] ")"] ":" Suite;

    ArgList: Argument ("," Argument)*  [","];

    // The reason that keywords are test nodes instead of "NAME" is that using "NAME"
    // results in an ambiguity. ast.c makes sure it's a "NAME".
    // "test "=" test" is really "keyword "=" test", but we have no such token.
    // These need to be in a single rule to avoid grammar that is ambiguous
    // to our LL(1) parser. Even though 'test' includes '*expr' in star_expr,
    // we explicitly match '*' here, too, to give it proper precedence.
    // Illegal combinations and orderings are blocked in ast.c:
    // multiple (test comp_for) arguments are blocked; keyword unpackings
    // that precede iterable unpackings are blocked; etc.
    Argument: ( Test [CompFor] |
                Test ":=" Test |
                Test "=" Test |
                "**" Test |
                "*" Test );

    CompIter: CompFor | CompIf;
    SyncCompFor: "for" ExprList "in" OrTest [CompIter];
    CompFor: ["async"] SyncCompFor;
    CompIf: "if" TestNoCond [CompIter];

    // not used in grammar, but may appear in "node" passed from Parser to Compiler
    EncodingDecl: "NAME";

    YieldExpr: "yield" [YieldArg];
    YieldArg: "from" Test | TestListStarExpr;

    FuncBodySuite: SimpleStmt | "NEWLINE" "INDENT" Stmt+ "DEDENT";

    FuncTypeInput: FuncType "NEWLINE"* "ENDMARKER";
    FuncType: "(" [TypeList] ")" "->" Test;
    // typelist is a modified typedargslist (see above)
    TypeList: (Test ("," Test)* [","
        ["*" [Test] ("," Test)* ["," "**" Test] | "**" Test]]
        |  "*" [Test] ("," Test)* ["," "**" Test] | "**" Test);
}

#[cfg(test)]
mod tests {
    use super::*;
    use lexer::tok;

    #[test]
    fn it_works() {
        let actual = next_state(NonTerminal::SingleInput, 0, &tok!("\n"));
        if let Next::Terminal(state, accept) = actual.unwrap() {
            assert_ne!(state, 0);
            assert_eq!(accept, true);
        } else {
            panic!("expected terminal");
        }

        let actual = next_state(NonTerminal::SingleInput, 0, &tok!("not"));
        if let Next::NonTerminal(nt, state, accept) = actual.unwrap() {
            assert_ne!(state, 0);
            assert_eq!(nt, NonTerminal::SimpleStmt);
            assert_eq!(accept, true);
        } else {
            panic!("expected non terminal");
        }

        let actual = next_state(NonTerminal::SingleInput, 0, &tok!("if"));
        if let Next::NonTerminal(nt, state, accept) = actual.unwrap() {
            assert_ne!(state, 0);
            assert_eq!(nt, NonTerminal::CompoundStmt);
            assert_eq!(accept, false);
        } else {
            panic!("expected non terminal");
        }
    }
}
